package ui.smartpro.coroutinecours.select

//В этом уроке разбираем оператор select

//Не так уж и просто описать общими словами назначение оператора select, поэтому начну объяснение
// сразу с примера - курсы валют.
//
//Нам надо отобразить данные по курсам валют от центрального банка. Мы запрашиваем эти данные у
// разных сервисов. Данные в ответах будут одинаковы. Цель нескольких запросов - получить данные как можно быстрее. Какой-то из сервисов будет самым быстрым и первый пришлет нам ответ. Остальные сервисы мы проигнорируем.
//
//Чтобы реализовать такой сценарий, нам нужен select. Мы запустим несколько параллельных async корутин
// с запросами, а select поможет получить результат только той корутины, которая отработает быстрее остальных.

//Давайте рассмотрим пример использования select с двумя async корутинами:

launch {

   val async1 = async { ... }
   val async2 = async { ... }

   val result = select<String> {

       // 1
       async1.onAwait {
           it
       }

       // 2
       async2.onAwait {
           // 4
           it
       }

       // 3
   }

   // 5

}
//Внутри launch мы стартуем пару async корутин, которые что-то делают. Мы запускаем select, чтобы
// получить результат от той из них, котора отработает быстрее. Предположим, что это будет вторая корутина.

//Я добавил каменты с цифрами, чтобы удобнее было объяснять, что тут происходит. Идем по пунктам.

//1.
//onAwait - это специальная форма вызова await. Она предназначена для работы с select.
// Т.е. просто await здесь не прокатит. Нужен именно onAwait.
//
//Под капотом метод onAwait берет два объекта. Во-первых - специальный объект SelectInstance из
// оператора select. Во-вторых - блок кода, который мы передаем в onAwait. В этот блок кода мы получим результат работы async.
//
//Напомню, что onAwait - это метод объекта Job. Того самого Job, который отвечает за работу async.
// Метод onAwait подписывает SelectInstance (вместе с блоком кода) на окончание работы этого Job.
//
//Когда async завершит работу, его Job уведомит об этом SelectInstance и выполнит блок кода из onAwait,
// передав туда результат своей работы. Но об этом чуть позже.

//2.
//Все то же самое происходит и для второго async.
//
//Теперь SelectInstance подписан на завершение двух корутин - async1 и async2.

//3.
//Выполнение кода select на этом завершается. Корутина launch приостанавливается, пока select ждет
// результат одного из async.

//3.5.
//Где-то там async2 завершает свою работу. Его Job сообщает об этом всем, кто подписался на его завершение.
// В числе этих подписчиков был SelectInstance.
//
//SelectInstance понимает, что у него теперь есть готовый результат из async2. Остальные результаты
// ему не нужны. Он отписывается от всех остальных Job, на завершение работы которых был подписан.
// В нашем случае - он отписывается от корутины async1.
//
//
//4.
//Job второго async запускает блок кода, который мы передавали в onAwait. В этот блок кода мы от
// Job получаем результат работы корутины async2. От нас требуется вернуть значение, которое будет
// результатом работы select. В нашем примере мы ничего не меняем и просто возвращаем результат,
// как есть. Именно он и уходит в переменную result.
//
//
//5.
//suspend функция select возобновляет выполнение корутины launch. В переменной result находится
// результат работы корутины async2, пропущенный через блок метода async2.onAwait.
//
//
//5.5.
//Где-то там async1 завершает свою работу. Его Job сообщает об этом всем, кто подписался на его
// завершение. Но в числе этих подписчиков уже не было SelectInstance. Он отписался, когда получил
// результат от async2. Соответственно async1.onAwait уже не вызывается.

//Timeout
//Кроме пары onAwait, мы можем поместить в select оператор onTimeout:

onTimeout(5000) {
   "timeout"
}
//Он сработает, если за указанное время так и не пришло результатов от async корутин.

//Что еще можно вызвать в select
//Полный список всегда можно посмотреть в документации. Кроме рассмотренного нами Deferred.onAwait,
// существует еще Job.onJoin. А также есть SendChannel.onSend и ReceiveChannel.onReceive,
// в случае которых select будет подписываться на ожидание отправки или получения данных.
//
//SendChannel.onSend удобно использовать, когда у нас есть данные, которые надо обработать,
// и есть несколько обработчиков. Каждый обработчик предоставляет нам Channel,
// куда мы можем отправить данные. И мы все эти отправки данных в каналы мы помещаем в select,
// как onSend. В итоге наши данные уйдут в канал первого освободившегося обработчика.
// А отправка в остальные будет отменена