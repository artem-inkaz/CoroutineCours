package ui.smartpro.coroutinecours.concurrency

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.sync.Mutex
import java.util.concurrent.atomic.AtomicInteger

//В этом уроке рассмотрим несколько простых примеров, в которых две корутины меняют одну переменную.
// К чему это приводит, и какие есть способы сделать это правильно.

//Под капотом корутин работают обычные потоки, поэтому тема потокобезопасности никуда не делась.
// Более подробно об этой теме можно почитать если загуглить java concurrency.
// Мы же сейчас рассмотрим только простые примеры.
//
//Урок сделан по мотивам официальной документации.

//Итак, вот пример, с которым мы будем работать:

viewModelScope.launch {

   var i = 0

   val job1 = launch(Dispatchers.Default) {
       repeat(100000) {
           i++
       }
   }

   val job2 = launch(Dispatchers.Default) {
       repeat(100000) {
           i++
       }
   }

   job1.join()
   job2.join()

   log("i = $i")
}
//В родительской корутине запускаем две дочерние (с диспетчером Default), каждая из которых 100 000
// раз увеличивает переменную i на 1. Далее мы ждем (join), пока они закончат работу и выводим в лог
// результат.
//
//Корутины будут работать параллельно, в разных потоках диспетчера Default. Т.е. они из разных потоков
// будут работать с одной переменной. Поэтому очевидно, что результата i = 200 000 ждать в итоге не
// приходится. У меня результат в среднем равен около 130 000.
//
//Давайте смотреть какие варианты решения у нас есть.

//Volatile
//Это магическое слово означает, что когда один поток меняет значение переменной, об этом сразу же
// знают все другие потоки.
//
//Но здесь это не поможет. Потому что i++ это i = i + 1. Т.е. тут поток читает значение переменной,
// увеличивает его на 1 и пишет обратно в переменную. Это не атомарная операция. В это время другой
// поток мог уже переписать значение.

//Последовательный запуск
//Попробуем запускать корутины последовательно друг за другом:

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
       i++
   }
}

job1.join()

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
       i++
   }
}

job2.join()

log("i = $i")
//Мы ждем окончания первой корутины и только потом запускам вторую. Переменная все так же меняется из
// двух разных потоков (хотя и необязательно - Default вполне может использовать один поток для двух
// последовательных корутин), но результат теперь будет корректный - 200 000. Потому что корутины
// работали не параллельно, а друг за другом.
//
//Но так не интересно. Можно было просто весь код в одну корутину поместить и получилось бы то же самое.
// Мы вообще то хотели, чтобы корутины работали параллельно

//Один поток
//Что если сделать корутины обратно параллельными, но попросить их выполняться в одном потоке.
// Тогда работа с переменной будет потокобезопасна.
//
//Создадим диспетчер с одним потоком:
//
//1
//val singleThreadDispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()
//И используем в корутинах:

val job1 = launch(singleThreadDispatcher) {
   repeat(100000) {
       i++
   }
}

val job2 = launch(singleThreadDispatcher) {
   repeat(100000) {
       i++
   }
}

job1.join()
job2.join()

log("i = $i")
//Результат полностью аналогичен предыдущему. Значение будет равно 200 000, но корутины выполнялись
// последовательно, потому что поток всего один. Сначала диспетчер выполнил первую корутину, а потом,
// когда поток освободился, - вторую. В одном потоке они не смогут выполняться параллельно.
//
//
//Ладно. А что если корутины оставить параллельными в Default диспетчере, а именно работу с переменной
// вынести в один поток с помощью withContext:

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
       withContext(singleThreadDispatcher) {
           i++
       }
   }
}

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
       withContext(singleThreadDispatcher) {
           i++
       }
   }
}

job1.join()
job2.join()

log("i = $i")
//Теперь обе корутины будут переключаться на один поток для работы с переменной. Результат будет 200 000.
// Корутины при этом работали параллельно. Вроде все ок. Но общее время работы увеличилось на порядки.
// Вместо 20-30 мсек, этот код теперь работает 10 000 мсек. Потому что в этом конкретном примере
// было слишком много переключений между потоками.
//
//Если бы корутины были больше заняты своей работой и только иногда обращались бы к общей переменной,
// то такой сценарий мог бы быть вполне рабочим.

//Atomic
//Перейдем к рабочим решениям. Самое простое - это Atomic классы.

var i = AtomicInteger()

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
           i.incrementAndGet()
   }
}

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
           i.incrementAndGet()
   }
}

job1.join()
job2.join()

log("i = $i")
//Работа параллельна и результат будет правильным. А также Atomic не сильно ухудшит скорость работы кода.

//synchronized
//Старый добрый synchronized тоже может выручить. Немного перепишем код под него:

var i = 0

@Synchronized
fun increment() {
   i++
}
//Сделаем отдельный synchronized метод для работы с переменной.

//Используем этот метод в корутинах:

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
           increment()
   }
}

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
       increment()
   }
}

job1.join()
job2.join()

log("i = $i")
//Работает достаточно быстро, параллельно и правильно.
//
//Но! Если где-то в корутинах вызываются suspend функции, которые приостанавливают выполнение кода, то в этот момент synchronized блокировки снимаются, и вся synchronized логика рушится.
//
//Об этом даже есть перевод статьи на хабре.

//Mutex
//Вместо synchronized рекомендуется в корутинах использовать Mutex. Перепишем метод increment:

val mutex = Mutex()
var i = 0

suspend fun increment() {
   mutex.withLock {
       i++
   }
}

//Код корутин остается тем же:

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
           increment()
   }
}

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
       increment()
   }
}

job1.join()
job2.join()

log("i = $i")
//В данном конкретном примере Mutex работает значительно дольше synchronized. Но в обычных боевых
// примерах разница будет не столь велика. В статье на хабре, ссылку на которую я привел чуть выше,
// автор пишет что разница составляет полтора-два раза.

//Actor
//Actor также может обеспечить нам потокобезопасность, потому что у него под капотом работает Channel,
// который был создан для безопасной передачи данных между корутинами.
//
//Создаем Actor, который будет менять переменную при каждом получении Unit.

private val actorChannel = viewModelScope.actor<Unit> {
   for (e in channel) {
       i++
   }
}
//Канал обеспечит нам синхронизацию. Все i++ в итоге выполняются в одной корутине, которая работает внутри Actor.
//
//А корутины будут параллельно слать Unit:

val job1 = launch(Dispatchers.Default) {
   repeat(100000) {
       actorChannel.send(Unit)
   }
}

val job2 = launch(Dispatchers.Default) {
   repeat(100000) {
       actorChannel.send(Unit)
   }
}

job1.join()
job2.join()

actorChannel.close()

log("i = $i")
//Результат будет правильный, но время работы - достаточно долгое. Этот вариант не особо подходит,
// если корутины мало работают сами, а только и делают, что отправляют данные в канал.