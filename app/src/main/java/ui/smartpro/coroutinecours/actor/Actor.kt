package ui.smartpro.coroutinecours.actor

//В этом уроке разбираем оператор actor

//actor поначалу кажется не очень понятной структурой, но на самом деле является всего лишь корутиной
// с каналом внутри.
//
//Т.е. при вызове оператора actor стартует корутина и создается канал, доступный внутри этой корутины.
// Этот канал мы получаем наружу, как результат вызова actor, и можем отправлять в него данные.
// А корутина будет эти данные получать и что-то с ними делать.
//
//В итоге получается корутина, в которую мы можем потокобезопасно передавать данные посредством канала.

//В качестве примера (пусть и не самого очевидного) можно рассмотреть реализацию защиты от
// множественных нажатий. У нас есть кнопка, по нажатию на которую, мы в корутине грузим данные с сервера.
// Нам надо сделать так, чтобы каждое нажатие не приводило к запуску новой корутины с загрузкой данных,
// пока текущая корутина не завершилась.
//
//Похожий пример мы уже рассматривали в уроке про Retrofit. Там мы просто использовали Job для проверки.

//Мы создадим actor в ViewModel. И будем использовать его канал для передачи события клика в корутину.
// А корутина будет загружать данные.
//
//Создаем actor:

private val actorChannel = viewModelScope.actor<Unit> {
   for (click in channel) {
       val data = apiService.getData()
       log("data = $data")
   }
}
//Его тип данных - Unit, потому что в его канал нам не надо передавать никаких реальных данных, только события кликов.
//
//В корутине мы используем for для ожидания события клика из канала, и как только клик поступил - грузим данные.

//Оператор actor возвращает нам Channel. Его мы используем в методе, который вызывается при нажатии на кнопку:

fun onButtonClick() {
   log("click")
   actorChannel.offer(Unit)
}
//В канал передаем просто Unit. Он придет в корутину. Корутина начнет загружать данные.

//Обратите внимание на метод канала, который мы используем для передачи. Это метод Channel.offer.
// В отличие от метода Channel.send, он не будет ждать готовности получателя данных канала.
// Если получатель не готов, то метод offer просто выполнится, ничего не отправив.
//
//Именно это и дает нам защиту от повторных нажатий. Пока корутина внутри actor загружает данные,
//
// она не готова принимать следующий клик от канала. Следовательно, все клики будут игнорироваться.
// Как только корутина загрузила данные, она переходит на новую итерацию внутри for и готова получать следующий клик.
//
//
//
//Я добавил логирование в код. А метод apiService.getData - фейковый, который просто ждет 1000 мсек
// и возвращает строку. Запустим приложение и понажимаем на кнопку:
//
//17:07:54.115 click
//17:07:54.754 click
//17:07:55.116 data = <some data>
//
//17:08:00.706 click
//17:08:01.030 click
//17:08:01.239 click
//17:08:01.475 click
//17:08:01.699 click
//17:08:01.707 data = <some data>
//
//17:08:01.915 click
//17:08:02.074 click
//17:08:02.232 click
//17:08:02.917 data = <some data>
//
//17:08:05.599 click
//17:08:05.772 click
//17:08:05.923 click
//17:08:06.081 click
//17:08:06.240 click
//17:08:06.399 click
//17:08:06.600 data = <some data>
//
//Логи разбиты на группы для наглядности. Видно, что между первым кликом в группе и получением данных
// проходит 1 секунда. А все клики, совершенные в эту секунду, игнорируются.

//Как остановить работу actor
//Со стороны канала это можно сделать вызывав метод actorChannel.close(). Корутина доработает
// текущую итерацию for до конца и завершится.
//
//Также можно отменить scope, в котором запущен actor. В этом случае цикл for в корутине выбросит
// JobCancellationException и работа корутины на этом завершится.

//Параметры
//У actor есть несколько параметров:
//
//context и start - аналогичны одноименным параметрам у launch, т.е. можно передать свой контекст
// и сделать корутину Lazy.
//
//capacity - аналогичен этому же параметру у каналов, т.е. устанавливает размер буфера канала.
//
//onCompletion - сюда можно передать блок кода, который будет выполнен по завершению работы actor.
// Сработает в обоих выше рассмотренных случаях остановки.