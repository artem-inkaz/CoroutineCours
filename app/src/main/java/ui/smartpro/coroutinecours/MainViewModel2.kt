package ui.smartpro.coroutinecours

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.delay

class MainViewModel2: ViewModel() {

    private val _liveData = MutableLiveData<String>()
    val liveData = _liveData as LiveData<String>

    init {
        viewModelScope.launch {
            while (true) {
                delay(1000)
                //Каждую секунду в LiveData передается значение work.
                _liveData.setValue("work")
            }
        }
    }

    val liveData2 = liveData<String> {
        while (true) {
            delay(1000)
            emit("work")
        }
    }
    //Билдер liveData создает корутину и возвращает LiveData. Внутри корутины мы используем метод emit,
// чтобы постить данные в получившуюся LiveData.
    //
    //
    //
    //Давайте разберем ключевые особенности этой пары.
    //
    //Время жизни создаваемой корутины зависит от наличия подписчика создаваемой LiveData.
// Т.е. под капотом создается scope, который завязан на состояние активности LiveData.
// Корутина стартует не в момент создания, а когда кто-либо подписывается на LiveData.
    //
    //Если подписчик решает отписаться когда корутина еще работает, то корутине дается таймаут
// 5 секунд на завершение своей работы. Если она не успеет закончить, то будет отменена.
// И когда кто-то снова подпишется на LiveData, корутина будет перезапущена.
    //
    //Если корутина нормально (без отмены по таймауту) заканчивает свою работу, то она уже
// не будет перезапущена при следующей подписке на LiveData.
    //
    //Т.е. можно сказать, что эта корутина - одноразовая. Успешно она выполнится только один раз.
// И у нас нет возможности ее перезапустить вручную чтобы, например, получить свежие данные.
// Надо будет создавать новую пару LiveData + корутина.
    //
    //Под капотом scope все тот же набор SupervisorJob и Dispatchers.Main.immediate.
// Но в билдер можно передать и свой контекст. Например, чтобы сменить диспетчера.
    //
    //
    //
    //Кратко рассмотрим, как liveData корутина (созданная в ViewModel) реагирует на основные
// lifecycle события Activity, если работа этой корутины еще не завершена.
    //
    //Закрытие экрана. При этом событии подписчик отпишется от LiveData. Корутина еще 5 секунд работает,
// а потом отменяется.
    //
    //Поворот экрана. Старый подписчик отписывается от LiveData, но тут же подписывается новый
// в создаваемом Activity. Состояние без подписчика явно будет длиться меньше чем 5 секунд,
// поэтому корутина не будет отменена, а продолжит свою работу с новым подписчиком LiveData.
    //
    //Сворачивание приложение больше, чем на 5 секунд. Подписчик отписывается от LiveData.
// Через 5 секунд корутина отменяется. Когда приложение снова будет открыто, возобновится и подписка.
// И т.к. корутина была отменена по таймауту, то она будет перезапущена.
// При этом у нас есть возможность внутри корутины узнать, какое последнее значение
// было отправлено (emit) перед таймаутом. Для этого используем latestValue.
}